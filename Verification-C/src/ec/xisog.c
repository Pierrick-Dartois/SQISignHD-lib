#include "isog.h"
#include "ec.h"
#include <assert.h>

// -------------------------------------------------------------------------
// -------------------------------------------------------------------------

// Degree-2 isogeny with kernel generated by P != (0 ,0)
// Outputs the curve coefficient in the form A24=(A+2C:4C)
void
xisog_2(ec_kps2_t *kps, ec_point_t *B, const ec_point_t P)
{
    fp2_sqr(&B->x, &P.x);
    fp2_sqr(&B->z, &P.z);
    fp2_sub(&B->x, &B->z, &B->x);
    fp2_add(&kps->K.x, &P.x, &P.z);
    fp2_sub(&kps->K.z, &P.x, &P.z);
}

// TODO we may be more efficient than that ?
void
xisog_2_singular(ec_kps2_t *kps, ec_point_t *B24, ec_point_t A24)
{
    fp2_t t0, four;
    fp2_set_small(&four, 4);
    fp2_add(&t0, &A24.x, &A24.x);
    fp2_sub(&t0, &t0, &A24.z);
    fp2_add(&t0, &t0, &t0);
    fp2_inv(&A24.z);
    fp2_mul(&t0, &t0, &A24.z);
    fp2_copy(&kps->K.x, &t0);
    fp2_add(&B24->x, &t0, &t0);
    fp2_sqr(&t0, &t0);
    fp2_sub(&t0, &t0, &four);
    fp2_sqrt(&t0);
    fp2_neg(&kps->K.z, &t0);
    fp2_add(&B24->z, &t0, &t0);
    fp2_add(&B24->x, &B24->x, &B24->z);
    fp2_add(&B24->z, &B24->z, &B24->z);
}

// Degree-4 isogeny with kernel generated by P such that [2]P != (0 ,0)
// Outputs the curve coefficient in the form A24=(A+2C:4C)
void
xisog_4(ec_kps4_t *kps, ec_point_t *B, const ec_point_t P)
{
    ec_point_t *K = kps->K;

    fp2_sqr(&K[0].x, &P.x);
    fp2_sqr(&K[0].z, &P.z);
    fp2_add(&K[1].x, &K[0].z, &K[0].x);
    fp2_sub(&K[1].z, &K[0].z, &K[0].x);
    fp2_mul(&B->x, &K[1].x, &K[1].z);
    fp2_sqr(&B->z, &K[0].z);

    // Constants for xeval_4
    fp2_add(&K[2].x, &P.x, &P.z);
    fp2_sub(&K[1].x, &P.x, &P.z);
    fp2_add(&K[0].x, &K[0].z, &K[0].z);
    fp2_add(&K[0].x, &K[0].x, &K[0].x);
}

// Degree-4 isogeny with kernel generated by P such that [2]P = (0 ,0)
void
xisog_4_singular(ec_kps4_t *kps, ec_point_t *B24, const ec_point_t P, ec_point_t A24)
{
    ec_point_t *K = kps->K;
    fp2_copy(&K[0].z, &A24.z);
    // If Px == Pz then
    // K[0].x = A24.x
    // K[1].x = A24.x - A24.z
    // B24.z  = -K[1].x
    // Otherwise
    // K[1].x = A24.x
    // K[0].x = A24.x - A24.z
    // B24.z  = K[1].x

    // Check whether P.x == P.z
    uint32_t xz_equal = fp2_is_equal(&P.x, &P.z);

    // Compute K[i].x as above
    fp2_copy(&K[1].x, &A24.x);
    fp2_sub(&K[0].x, &A24.x, &A24.z);
    fp2_cswap(&K[0].x, &K[1].x, xz_equal);

    // Compute B24
    fp2_t tmp;
    fp2_neg(&tmp, &K[1].x);
    fp2_select(&B24->z, &K[1].x, &tmp, xz_equal);
    fp2_copy(&B24->x, &K[0].z);
}

// 3-isogeny with kernel generated by P. Optimized formulas found in https://eprint.iacr.org/2017/504.pdf (Appendix A)
void 
xisog_3(ec_kps_t *kps, ec_point_t *B24, const ec_point_t P)
{
    ec_point_t K;
    fp2_t r1, r2, r3, r4, r5;

    fp2_sub(&K.x,&P.x,&P.z);
    fp2_add(&K.z,&P.x,&P.z);

    kps->K=(ec_point_t *)malloc(sizeof(ec_point_t));
    kps->K[0]=K;

    fp2_sqr(&r1,&K.x); // r1=K1^2 ((x-z)^2)
    fp2_sqr(&r2,&K.z); // r2=K2^2 ((x+z)^2)
    fp2_add(&r3,&r1,&r2); //r3=r1+r2 ((x-z)^2+(x+z)^2=2(x^2+z^2))
    fp2_add(&r4,&K.x,&K.z); // r4=K1+K2 (2x)
    fp2_sqr(&r4,&r4); // r4=r4^2 (4x^2)
    fp2_sub(&r4,&r4,&r3); // r4=r4-r3 (2(x^2-z^2))
    fp2_add(&r3,&r4,&r2); // r3=r4+r2 ((x+z)(3x-z))
    fp2_add(&r4,&r4,&r1); // r4=r4+r1 ((x-z)(3x+z))
    fp2_add(&r5,&r1,&r4); // r5=r1+r4 (4x(x-z))
    fp2_add(&r5,&r5,&r5); // r5=2r5 (8x(x-z))
    fp2_add(&r5,&r5,&r2); // r5=r5+r2 (8x(x-z)+(x+z)^2=9x^2-6xz+z^2=(3x-z)^2)
    fp2_mul(&B24->x,&r3,&r5); // A24=r3.r5=(x+z)(3x-z)^3
    fp2_add(&r5,&r2,&r3); // r5=r2+r3 (4x(x+z))
    fp2_add(&r5,&r5,&r5); // r5=2r5 (8x(x+z))
    fp2_add(&r5,&r5,&r1); // r5=r5+r1 (8x(x+z)+(x-z)^2=9x^2+6xz+z^2=(3x+z)^2)
    fp2_mul(&r5,&r5,&r4); // r5=r5.r4 ((x-z)(3x+z)^3)
    fp2_sub(&B24->z,&r5,&B24->x); // C24=r5-A24=-16xz^3. 
    fp2_add(&B24->x,&B24->x,&B24->z); // (A-2C:4C) -> (A+2C:4C). OK
}

// (2d+1)-isogeny with kernel generated by P. Optimized formulas found in https://eprint.iacr.org/2017/504.pdf (Algorithm 2)
void
xisog_odd(ec_kps_t *kps, ec_point_t *B24, const ec_point_t P, const ec_point_t *A24, ec_point_t P2, unsigned int d)
{
    // P2 is a 2-torsion point !=(0,0) used to recover the codomain B24
    ec_point_t kpsK[d], Q2;

    copy_point(&kpsK[0],&P);
    xDBL_A24(&kpsK[1],&P,A24);
    for(int i=2; i<d;i++){
        xADD(&kpsK[i],&kpsK[i-1],&P,&kpsK[i-2]);
    }

    kps->K=(ec_point_t *)malloc(d*sizeof(ec_point_t));
    for(int i=0;i<d;i++){
        kps->K[i]=kpsK[i];
    }

    xeval_odd(&Q2, &P2, 1, kps, d);
    fp2_add(&B24->x,&Q2.x,&Q2.z); // x+z
    fp2_sqr(&B24->x,&B24->x); // (x+z)^2
    fp2_sub(&B24->z,&Q2.x,&Q2.z); // x-z
    fp2_sqr(&B24->z,&B24->z); // (x-z)^2
    fp2_sub(&B24->z,&B24->z,&B24->x); // (x-z)^2-(x+z)^2
}
