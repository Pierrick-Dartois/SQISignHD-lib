#include "isog.h"
#include "ec.h"
#include <assert.h>

// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------

// Degree-2 isogeny evaluation with kenerl generated by P != (0, 0)
void
xeval_2(ec_point_t *R, ec_point_t *const Q, const int lenQ, const ec_kps2_t *kps)
{
    fp2_t t0, t1, t2;
    for (int j = 0; j < lenQ; j++) {
        fp2_add(&t0, &Q[j].x, &Q[j].z);
        fp2_sub(&t1, &Q[j].x, &Q[j].z);
        fp2_mul(&t2, &kps->K.x, &t1);
        fp2_mul(&t1, &kps->K.z, &t0);
        fp2_add(&t0, &t2, &t1);
        fp2_sub(&t1, &t2, &t1);
        fp2_mul(&R[j].x, &Q[j].x, &t0);
        fp2_mul(&R[j].z, &Q[j].z, &t1);
    }
}

void
xeval_2_singular(ec_point_t *R, const ec_point_t *Q, const int lenQ, const ec_kps2_t *kps)
{
    fp2_t t0, t1;
    for (int i = 0; i < lenQ; i++) {
        fp2_mul(&t0, &Q[i].x, &Q[i].z);
        fp2_mul(&t1, &kps->K.x, &Q[i].z);
        fp2_add(&t1, &t1, &Q[i].x);
        fp2_mul(&t1, &t1, &Q[i].x);
        fp2_sqr(&R[i].x, &Q[i].z);
        fp2_add(&R[i].x, &R[i].x, &t1);
        fp2_mul(&R[i].z, &t0, &kps->K.z);
    }
}

// Degree-4 isogeny evaluation with kenerl generated by P such that [2]P != (0, 0)
void
xeval_4(ec_point_t *R, const ec_point_t *Q, const int lenQ, const ec_kps4_t *kps)
{
    const ec_point_t *K = kps->K;

    fp2_t t0, t1;

    for (int i = 0; i < lenQ; i++) {
        fp2_add(&t0, &Q[i].x, &Q[i].z);
        fp2_sub(&t1, &Q[i].x, &Q[i].z);
        fp2_mul(&(R[i].x), &t0, &K[1].x);
        fp2_mul(&(R[i].z), &t1, &K[2].x);
        fp2_mul(&t0, &t0, &t1);
        fp2_mul(&t0, &t0, &K[0].x);
        fp2_add(&t1, &(R[i].x), &(R[i].z));
        fp2_sub(&(R[i].z), &(R[i].x), &(R[i].z));
        fp2_sqr(&t1, &t1);
        fp2_sqr(&(R[i].z), &(R[i].z));
        fp2_add(&(R[i].x), &t0, &t1);
        fp2_sub(&t0, &t0, &(R[i].z));
        fp2_mul(&(R[i].x), &(R[i].x), &t1);
        fp2_mul(&(R[i].z), &(R[i].z), &t0);
    }
}

// Degree-4 isogeny evaluation with kenerl generated by P such that [2]P = (0, 0)
// Must call after xisog_4_singular
void
xeval_4_singular(ec_point_t *R,
                 const ec_point_t *Q,
                 const int lenQ,
                 const ec_point_t P,
                 const ec_kps4_t *kps)
{
    const ec_point_t *K = kps->K;

    fp2_t t0, t1, t2;
    for (int i = 0; i < lenQ; i++) {
        fp2_add(&t0, &Q[i].x, &Q[i].z);
        fp2_sub(&t2, &Q[i].x, &Q[i].z);
        fp2_sqr(&t0, &t0);
        fp2_sqr(&t2, &t2);
        fp2_sub(&R[i].z, &t0, &t2);

        // if P.x == P.z then we want to set:
        // t0 = t0, t1 = t2
        // otherwise
        // t1 = t0 and t0 = t2
        uint32_t xz_equal = fp2_is_equal(&P.x, &P.z);
        fp2_select(&t1, &t0, &t2, xz_equal);
        fp2_select(&t0, &t2, &t0, xz_equal);

        fp2_mul(&R[i].x, &R[i].z, &K[0].x);
        fp2_mul(&R[i].z, &R[i].z, &K[1].x);
        fp2_mul(&R[i].z, &R[i].z, &t1);
        fp2_mul(&t1, &t1, &K[0].z);
        fp2_add(&R[i].x, &R[i].x, &t1);
        fp2_mul(&R[i].x, &R[i].x, &t0);
    }
}

// 3-isogeny evaluation
void
xeval_3(ec_point_t *R, ec_point_t *const Q, const int lenQ, const ec_kps_t *kps)
{
    fp2_t r1, r2, r3;
    for(int j=0;j<lenQ;j++){
        fp2_add(&r2,&Q[j].x,&Q[j].z); // r2=x+z
        fp2_mul(&r3,&r2,&kps->K[0].x); // r3=r2.K1 ((x3-z3)(x+z))
        fp2_sub(&r2,&Q[j].x,&Q[j].z); // r2=x-z
        fp2_mul(&r1,&r2,&kps->K[0].z); // r1=r2.K2 ((x3+z3)(x-z))
        fp2_add(&r2,&r1,&r3); // r2=r1+r3 (2(xx3-zz3))
        fp2_sqr(&r2,&r2); // r2=r2^2 (4(xx3-zz3)^2)
        fp2_mul(&R[j].x,&r2,&Q[j].x); // x'=r2.x=4x(xx3-zz3)^2
        fp2_sub(&r1,&r3,&r1); // r1=r3-r1 (2(x3z-z3x))
        fp2_sqr(&r1,&r1); // r1=r1^2 (4(x3z-z3x)^2)
        fp2_mul(&R[j].z,&r1,&Q[j].z); //z'=r1.z (4z(x3z-z3x)^2). OK
    }
}

static void
criss_cross(fp2_t *t1, fp2_t *t2, const fp2_t *a, const fp2_t *b, const fp2_t *c, const fp2_t *d){
    fp2_t t3, t4;
    fp2_mul(&t3,a,d);
    fp2_mul(&t4,b,c);
    fp2_add(t1,&t3,&t4);
    fp2_sub(t2,&t3,&t4);
}

// (2d+1)-isogeny evaluation https://eprint.iacr.org/2017/504.pdf (Algoritm 3)
void
xeval_odd(ec_point_t *R, ec_point_t *const Q, const int lenQ, const ec_kps_t *kps, unsigned int d)
{
    fp2_t x_dual, z_dual, t0, t1;

    for(int j=0; j<lenQ; j++){
        fp2_add(&x_dual,&Q[j].x,&Q[j].z);
        fp2_sub(&z_dual,&Q[j].x,&Q[j].z);
        criss_cross(&R[j].x,&R[j].z,&kps->K[0].x,&kps->K[0].z,&x_dual,&z_dual);
        for(int i=1;i<d;i++){
            criss_cross(&t0,&t1,&kps->K[i].x,&kps->K[i].z,&x_dual,&z_dual);
            fp2_mul(&R[j].x,&R[j].x,&t0);
            fp2_mul(&R[j].z,&R[j].z,&t1);
        }
        fp2_sqr(&R[j].x,&R[j].x);
        fp2_mul(&R[j].x,&R[j].x,&Q[j].x);
        fp2_sqr(&R[j].z,&R[j].z);
        fp2_mul(&R[j].z,&R[j].z,&Q[j].z);
    }

}