#include "isog.h"
#include "ec.h"
#include <assert.h>

// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------

// Degree-2 isogeny evaluation with kenerl generated by P != (0, 0)
void
xeval_2(ec_point_t *R, ec_point_t *const Q, const int lenQ, const ec_kps2_t *kps)
{
    fp2_t t0, t1, t2;
    for (int j = 0; j < lenQ; j++) {
        fp2_add(&t0, &Q[j].x, &Q[j].z);
        fp2_sub(&t1, &Q[j].x, &Q[j].z);
        fp2_mul(&t2, &kps->K.x, &t1);
        fp2_mul(&t1, &kps->K.z, &t0);
        fp2_add(&t0, &t2, &t1);
        fp2_sub(&t1, &t2, &t1);
        fp2_mul(&R[j].x, &Q[j].x, &t0);
        fp2_mul(&R[j].z, &Q[j].z, &t1);
    }
}

void
xeval_2_singular(ec_point_t *R, const ec_point_t *Q, const int lenQ, const ec_kps2_t *kps)
{
    fp2_t t0, t1;
    for (int i = 0; i < lenQ; i++) {
        fp2_mul(&t0, &Q[i].x, &Q[i].z);
        fp2_mul(&t1, &kps->K.x, &Q[i].z);
        fp2_add(&t1, &t1, &Q[i].x);
        fp2_mul(&t1, &t1, &Q[i].x);
        fp2_sqr(&R[i].x, &Q[i].z);
        fp2_add(&R[i].x, &R[i].x, &t1);
        fp2_mul(&R[i].z, &t0, &kps->K.z);
    }
}

// Degree-4 isogeny evaluation with kenerl generated by P such that [2]P != (0, 0)
void
xeval_4(ec_point_t *R, const ec_point_t *Q, const int lenQ, const ec_kps4_t *kps)
{
    const ec_point_t *K = kps->K;

    fp2_t t0, t1;

    for (int i = 0; i < lenQ; i++) {
        fp2_add(&t0, &Q[i].x, &Q[i].z);
        fp2_sub(&t1, &Q[i].x, &Q[i].z);
        fp2_mul(&(R[i].x), &t0, &K[1].x);
        fp2_mul(&(R[i].z), &t1, &K[2].x);
        fp2_mul(&t0, &t0, &t1);
        fp2_mul(&t0, &t0, &K[0].x);
        fp2_add(&t1, &(R[i].x), &(R[i].z));
        fp2_sub(&(R[i].z), &(R[i].x), &(R[i].z));
        fp2_sqr(&t1, &t1);
        fp2_sqr(&(R[i].z), &(R[i].z));
        fp2_add(&(R[i].x), &t0, &t1);
        fp2_sub(&t0, &t0, &(R[i].z));
        fp2_mul(&(R[i].x), &(R[i].x), &t1);
        fp2_mul(&(R[i].z), &(R[i].z), &t0);
    }
}

// Degree-4 isogeny evaluation with kenerl generated by P such that [2]P = (0, 0)
// Must call after xisog_4_singular
void
xeval_4_singular(ec_point_t *R,
                 const ec_point_t *Q,
                 const int lenQ,
                 const ec_point_t P,
                 const ec_kps4_t *kps)
{
    const ec_point_t *K = kps->K;

    fp2_t t0, t1, t2;
    for (int i = 0; i < lenQ; i++) {
        fp2_add(&t0, &Q[i].x, &Q[i].z);
        fp2_sub(&t2, &Q[i].x, &Q[i].z);
        fp2_sqr(&t0, &t0);
        fp2_sqr(&t2, &t2);
        fp2_sub(&R[i].z, &t0, &t2);

        // if P.x == P.z then we want to set:
        // t0 = t0, t1 = t2
        // otherwise
        // t1 = t0 and t0 = t2
        uint32_t xz_equal = fp2_is_equal(&P.x, &P.z);
        fp2_select(&t1, &t0, &t2, xz_equal);
        fp2_select(&t0, &t2, &t0, xz_equal);

        fp2_mul(&R[i].x, &R[i].z, &K[0].x);
        fp2_mul(&R[i].z, &R[i].z, &K[1].x);
        fp2_mul(&R[i].z, &R[i].z, &t1);
        fp2_mul(&t1, &t1, &K[0].z);
        fp2_add(&R[i].x, &R[i].x, &t1);
        fp2_mul(&R[i].x, &R[i].x, &t0);
    }
}

// Isogeny evaluation on Montgomery curves
// Recall: K has been computed in Twisted Edwards model and none extra additions are required.

// CrissCross procedure as described in Hisil and Costello paper
void
CrissCross(fp2_t *r0,
           fp2_t *r1,
           fp2_t const alpha,
           fp2_t const beta,
           fp2_t const gamma,
           fp2_t const delta)
{
    fp2_t t_1, t_2;

    fp2_mul(&t_1, &alpha, &delta);
    fp2_mul(&t_2, &beta, &gamma);
    fp2_add(&*r0, &t_1, &t_2);
    fp2_sub(&*r1, &t_1, &t_2);
}

void
xeval_t(ec_point_t *Q, uint64_t const i, ec_point_t const P)
{
    int j;
    int d = ((int)TORSION_ODD_PRIMES[i] - 1) / 2; // Here, l = 2d + 1

    fp2_t R0, R1, S0, S1, T0, T1;
    fp2_add(&S0, &P.x, &P.z);
    fp2_sub(&S1, &P.x, &P.z);

    CrissCross(&R0, &R1, K[0].z, K[0].x, S0, S1);
    for (j = 1; j < d; j++) {
        CrissCross(&T0, &T1, K[j].z, K[j].x, S0, S1);
        fp2_mul(&R0, &T0, &R0);
        fp2_mul(&R1, &T1, &R1);
    };

    fp2_sqr(&R0, &R0);
    fp2_sqr(&R1, &R1);

    fp2_mul(&(Q->x), &P.x, &R0);
    fp2_mul(&(Q->z), &P.z, &R1);
}
