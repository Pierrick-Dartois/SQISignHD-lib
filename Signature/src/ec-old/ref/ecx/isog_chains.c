#include "isog.h"
#include <assert.h>

static void ec_eval4_singular(ec_point_t* A24, ec_point_t* K, ec_point_t* G, unsigned short lenG, ec_point_t* points, unsigned short lenPoints){
/*
* Pushes G and points thourgh a 4-isogeny generated by a point K such that 2*K=(0,0)
* Also recomputes the curve coefficient A24 = (A+2C:4C) inplace
*/
    int j;
    fp2_t t0, t1, t2;
    ec_point_t KK;
    copy_point(&KK, K);
    // Isomorphism to move the point of order 4 to (1,-)
    fp2_add(&A24->x, &A24->x, &A24->x);
    fp2_sub(&A24->x, &A24->x, &A24->z);
    fp2_add(&A24->x, &A24->x, &A24->x);
    fp2_mul(&A24->x, &A24->x, &KK.z);
    fp2_mul(&A24->z, &A24->z, &KK.x);
    for(j = 0; j < lenPoints; j++){
        fp2_mul(&points[j].x, &points[j].x, &KK.z);
        fp2_mul(&points[j].z, &points[j].z, &KK.x);
    }
    for(j = 0; j < lenG; j++){
    fp2_mul(&G[j].x, &G[j].x, &KK.z);
    fp2_mul(&G[j].z, &G[j].z, &KK.x);
    }
    // xEval4 for points
    for(j = 0; j < lenPoints; j++){
        // Step1
        fp2_sub(&t0, &points[j].x, &points[j].z);
        fp2_mul(&points[j].z, &points[j].x, &points[j].z);
        fp2_sqr(&points[j].x, &t0);
        // Step2
        fp2_mul(&t2, &A24->x, &points[j].z);
        fp2_add(&t0, &points[j].z, &points[j].z);
        fp2_mul(&points[j].z, &points[j].z, &points[j].x);
        fp2_add(&t1, &points[j].x, &t0); // x+2z
        fp2_mul(&points[j].x, &t1, &A24->z);
        fp2_add(&points[j].x, &points[j].x, &t2); //(x+2z)*C+A
        fp2_add(&t1, &t1, &t0); //x+4z
        fp2_mul(&points[j].x, &points[j].x, &t1);
        fp2_sub(&t1, &A24->z, &A24->x);
        fp2_add(&t1, &t1, &A24->z);
        fp2_mul(&points[j].z, &points[j].z, &t1);
    }
    // xEval4 for G
    for(j = 0; j < lenG; j++){
        // Step1
        fp2_sub(&t0, &G[j].x, &G[j].z);
        fp2_mul(&G[j].z, &G[j].x, &G[j].z);
        fp2_sqr(&G[j].x, &t0);
        // Step2
        fp2_mul(&t2, &A24->x, &G[j].z); //Az
        fp2_add(&t0, &G[j].z, &G[j].z); 
        fp2_mul(&G[j].z, &G[j].z, &G[j].x);
        fp2_add(&t1, &G[j].x, &t0); // x+2z
        fp2_mul(&G[j].x, &t1, &A24->z);
        fp2_add(&G[j].x, &G[j].x, &t2); //(x+2z)*C+A*z
        fp2_add(&t1, &t1, &t0); //x+4z
        fp2_mul(&G[j].x, &G[j].x, &t1);
        fp2_sub(&t1, &A24->z, &A24->x);
        fp2_add(&t1, &t1, &A24->z);
        fp2_mul(&G[j].z, &G[j].z, &t1);
    }
    // Update curve
    fp2_add(&t0, &A24->z, &A24->z);
    fp2_sub(&A24->z, &A24->x, &t0);
    fp2_add(&A24->x, &A24->x, &t0);
    fp2_add(&A24->x, &A24->x, &t0);
    fp2_add(&A24->x, &A24->x, &t0);
    fp2_add(&A24->x, &A24->x, &A24->x);
    fp2_add(&A24->z, &A24->z, &A24->z);
    fp2_add(&A24->x, &A24->x, &A24->z);
    fp2_add(&A24->z, &A24->z, &A24->z);
    copy_point(K, &KK);
}

static void ec_isom2(ec_point_t* A24, ec_point_t* G, ec_point_t* K, ec_point_t* points, unsigned short length){
/*
* Pushes G,K and points thourgh an isomorphism that moves (0,0) to (a,-) with a!=0
* Also recomputes the curve coefficient A24 = (A+2C:4C) inplace
*/
    fp2_t t0, t1, t2, A;
    ec_point_t KK;
    copy_point(&KK, K);

    fp2_add(&A, &A24->x, &A24->x);
    fp2_sub(&A, &A, &A24->z);
    fp2_add(&A, &A, &A);
    // Find point of order 4 that is not (1,-)
    ec_point_t P4, P2, P0;
    fp2_t x;
    fp_mont_setone(x.re);
    fp_set(x.im, 0);
    while(1){
        fp_add(x.im, x.re, x.im);

        // Check if point is rational
        fp2_sqr(&t0, &A24->z);
        fp2_mul(&t1, &t0, &x);
        fp2_mul(&t2, &A, &A24->z);
        fp2_add(&t1, &t1, &t2);
        fp2_mul(&t1, &t1, &x);
        fp2_add(&t1, &t1, &t0);
        fp2_mul(&t1, &t1, &x);
        if(fp2_is_square(&t1)){
            fp2_copy(&P4.x, &x);
            fp_mont_setone(P4.z.re);
            fp_set(P4.z.im, 0);
        }
        else
            continue;

        // Clear odd factors from the order
        xMULv2(&P4, &P4, p_cofactor_for_2f, P_COFACTOR_FOR_2F_BITLENGTH, A24);

        // Get point of order 4
        xDBLv2(&P2, &P4, A24);
        if(ec_is_zero(&P2))
            continue;
        xDBLv2(&P0, &P2, A24);
        while(!ec_is_zero(&P0)){
            copy_point(&P4, &P2);
            copy_point(&P2, &P0);
            xDBLv2(&P0, &P0, A24);
        }
        if(fp2_is_zero(&P2.x))
            continue;
        else
            break;
    }       
    // Evaluate isomorphism
    fp2_add(&t0, &P2.x, &P2.x);
    fp2_add(&t0, &t0, &P2.x);
    fp2_mul(&t0, &t0, &A24->z);
    fp2_mul(&t1, &A, &P2.z);
    fp2_add(&A24->x, &t0, &t1);
    fp2_mul(&A24->x, &A24->x, &P4.z);
    fp2_mul(&t0, &P4.x, &P2.z);
    fp2_mul(&t1, &P2.x, &P4.z);
    fp2_sub(&t0, &t0, &t1);
    fp2_mul(&A24->z, &A24->z, &t0);
    fp2_add(&A24->z, &A24->z, &A24->z);
    fp2_add(&A24->x, &A24->x, &A24->z);
    fp2_add(&A24->z, &A24->z, &A24->z);
    for(int j = 0; j < length; j++){
        fp2_mul(&t0, &points[j].x, &P2.z);
        fp2_mul(&t1, &P2.x, &points[j].z);
        fp2_sub(&t0, &t0, &t1);
        fp2_mul(&points[j].x, &t0, &P4.z);
        fp2_mul(&t0, &P4.x, &P2.z);
        fp2_mul(&t1, &P2.x, &P4.z);
        fp2_sub(&t0, &t0, &t1);
        fp2_mul(&points[j].z, &points[j].z, &t0);
    }
    fp2_mul(&t0, &G->x, &P2.z);
    fp2_mul(&t1, &P2.x, &G->z);
    fp2_sub(&t0, &t0, &t1);
    fp2_mul(&G->x, &t0, &P4.z);
    fp2_mul(&t0, &P4.x, &P2.z);
    fp2_mul(&t1, &P2.x, &P4.z);
    fp2_sub(&t0, &t0, &t1);
    fp2_mul(&G->z, &G->z, &t0);
    fp2_mul(&t0, &KK.x, &P2.z);
    fp2_mul(&t1, &P2.x, &KK.z);
    fp2_sub(&t0, &t0, &t1);
    fp2_mul(&KK.x, &t0, &P4.z);
    fp2_mul(&t0, &P4.x, &P2.z);
    fp2_mul(&t1, &P2.x, &P4.z);
    fp2_sub(&t0, &t0, &t1);
    fp2_mul(&KK.z, &KK.z, &t0);
    copy_point(K, &KK);
}

void ec_eval_even(ec_curve_t* image, const ec_isog_even_t* phi,
    ec_point_t* points, unsigned short length){
    
    assert(phi->length == POWER_OF_2);
        
    uint8_t log2_of_e, tmp;
    fp2_t t0;
    digit_t e_half = (phi->length)>>1;
    for(tmp = e_half, log2_of_e = 0; tmp > 0; tmp>>=1, ++log2_of_e);
    log2_of_e *= 2; // In order to ensure each splits is at most size log2_of_e
    // TODO: don't we want +1 instead of *2?

    printf("e_half = %i\n", e_half);
    printf("log2_of_e = %i\n", log2_of_e);

    ec_point_t SPLITTING_POINTS[log2_of_e], K2;
    copy_point(&SPLITTING_POINTS[0], &phi->kernel);

    // Curve in the form A24=(A+2C:4C)
    ec_point_t A24;
    fp2_add(&A24.z, &phi->curve.C, &phi->curve.C);
    fp2_add(&A24.x, &phi->curve.A, &A24.z);
    fp2_add(&A24.z, &A24.z, &A24.z);

    int strategy = 0,    // Current element of the strategy to be used
    local_i, local_j;

    int BLOCK = 0,       // BLOCK is used for determined when a point has order l
    current = 0;         // At the beginning we have only one point in each split
    int XDBLs[log2_of_e]; // The current number of doublings performed

    // If the exponent is odd, we start by computing a 2-isogeny
    if (phi->length % 2 == 1)
    {
        copy_point(&SPLITTING_POINTS[1], &SPLITTING_POINTS[0]);
        for(local_i = 0; local_i < phi->length - 1; local_i++)
            xDBLv2(&SPLITTING_POINTS[1], &SPLITTING_POINTS[1], &A24);
        // Special case when the kernel is (0,0), push through isomorphism
        if(fp2_is_zero(&SPLITTING_POINTS[1].x)){
            ec_isom2(&A24, &SPLITTING_POINTS[1], &SPLITTING_POINTS[0], points, length);
        }
        // xIsog2
        fp2_sqr(&A24.x, &SPLITTING_POINTS[1].x);
        fp2_sqr(&A24.z, &SPLITTING_POINTS[1].z);
        fp2_sub(&A24.x, &A24.z, &A24.x);
        fp2_add(&K2.x, &SPLITTING_POINTS[1].x, &SPLITTING_POINTS[1].z);
        fp2_sub(&K2.z, &SPLITTING_POINTS[1].x, &SPLITTING_POINTS[1].z);
        // xEval2 for push points
        for(local_j = 0; local_j < length; local_j++){
            fp2_add(&SPLITTING_POINTS[1].x, &points[local_j].x, &points[local_j].z);
            fp2_sub(&SPLITTING_POINTS[1].z, &points[local_j].x, &points[local_j].z);
            fp2_mul(&t0, &K2.x, &SPLITTING_POINTS[1].z);
            fp2_mul(&SPLITTING_POINTS[1].z, &K2.z, &SPLITTING_POINTS[1].x);
            fp2_add(&SPLITTING_POINTS[1].x, &t0, &SPLITTING_POINTS[1].z);
            fp2_sub(&SPLITTING_POINTS[1].z, &t0, &SPLITTING_POINTS[1].z);
            fp2_mul(&points[local_j].x, &points[local_j].x, &SPLITTING_POINTS[1].x);
            fp2_mul(&points[local_j].z, &points[local_j].z, &SPLITTING_POINTS[1].z);
        }
        // xEval2 for splitting points
        fp2_add(&SPLITTING_POINTS[1].x, &SPLITTING_POINTS[0].x, &SPLITTING_POINTS[0].z);
        fp2_sub(&SPLITTING_POINTS[1].z, &SPLITTING_POINTS[0].x, &SPLITTING_POINTS[0].z);
        fp2_mul(&t0, &K2.x, &SPLITTING_POINTS[1].z);
        fp2_mul(&SPLITTING_POINTS[1].z, &K2.z, &SPLITTING_POINTS[1].x);
        fp2_add(&SPLITTING_POINTS[1].x, &t0, &SPLITTING_POINTS[1].z);
        fp2_sub(&SPLITTING_POINTS[1].z, &t0, &SPLITTING_POINTS[1].z);
        fp2_mul(&SPLITTING_POINTS[0].x, &SPLITTING_POINTS[0].x, &SPLITTING_POINTS[1].x);
        fp2_mul(&SPLITTING_POINTS[0].z, &SPLITTING_POINTS[0].z, &SPLITTING_POINTS[1].z);
    }
    // All remaining isogenies are of degree 4
    for(local_j = 0; local_j < (e_half - 1); local_j++)
    {   
        // Get the next point of order 4

        printf("f %d\n", e_half -  1 - local_j);
        while (BLOCK != (e_half -  1 - local_j) )
        {
            // A new split will be added
            current += 1;
            // We set the seed of the new split to be computed and saved
            copy_point(&SPLITTING_POINTS[current], &SPLITTING_POINTS[current - 1]);
            printf("f1\n");
            for(local_i = 0; local_i < 2*STRATEGY2[strategy]; local_i++)
                xDBLv2(&SPLITTING_POINTS[current], &SPLITTING_POINTS[current], &A24);
            printf("f2 %d %d %d %d\n", current, log2_of_e, strategy, 36);
            XDBLs[current] = STRATEGY2[strategy];  // The number of doublings performed is saved
            BLOCK += STRATEGY2[strategy];          // BLOCK is increased by the number of doublings performed
            strategy += 1;                  // Next, we move to the next element of the strategy
        }
        // Evaluate 4-isogeny
        xDBLv2(&K2, &SPLITTING_POINTS[current], &A24);
        if(fp2_is_zero(&K2.x)){
            // Special case when (0,0) is in the kernel
            ec_eval4_singular(&A24, &SPLITTING_POINTS[current], SPLITTING_POINTS, current, points, length);
        }
        else{
            kps_4(SPLITTING_POINTS[current]);
            xisog_4(&A24, SPLITTING_POINTS[current]);
            for(local_i = 0; local_i < current; local_i++)
                xeval_4(&SPLITTING_POINTS[local_i], SPLITTING_POINTS[local_i]);
            for(local_i = 0; local_i < length; local_i++)
                xeval_4(&points[local_i], points[local_i]);
        }

        BLOCK -= XDBLs[current];   // BLOCK is decreased by the last number of doublings performed
        XDBLs[current] = 0;        // The last element in the splits are removed
        current -= 1;              // The number of splits is decreased by one
    }
    printf("g\n");

    // Final 4-isogeny
    xDBLv2(&K2, &SPLITTING_POINTS[current], &A24);
    if(fp2_is_zero(&K2.x)){
        // Special case when (0,0) is in the kernel
        ec_eval4_singular(&A24, &SPLITTING_POINTS[current], SPLITTING_POINTS, 0, points, length);
    }
    else{
        kps_4(SPLITTING_POINTS[current]);
        xisog_4(&A24, SPLITTING_POINTS[current]);
        for(local_i = 0; local_i < length; local_i++)
            xeval_4(&points[local_i], points[local_i]);
    }
    printf("h\n");
    // Output curve
    fp2_add(&image->A, &A24.x, &A24.x);
    fp2_sub(&image->A, &image->A, &A24.z);
    fp2_add(&image->A, &image->A, &image->A);
    fp2_copy(&image->C, &A24.z);
}

void ec_eval_even_nonzero(ec_curve_t* image, const ec_isog_even_t* phi,
    ec_point_t* points, unsigned short length){
        
    ec_point_t G, K, A24;
    int i,j;
    copy_point(&G, &phi->kernel);

    // Curve coefficient in the form A24 = (A+2C:4C)
    fp2_add(&A24.z, &phi->curve.C, &phi->curve.C);
    fp2_add(&A24.x, &phi->curve.A, &A24.z);
    fp2_add(&A24.z, &A24.z, &A24.z);
    
    // Chain of 4-isogenies
    for(i = 0; i+2 <= phi->length; i+=2){
        copy_point(&K, &G);
        for(j = 0; j < phi->length-i-2; j++)
            xDBLv2(&K, &K, &A24);

        kps_4(K);
        xisog_4(&A24, K);
        xeval_4(&G, G);
        for(j = 0; j < length; j++)
            xeval_4(&points[j], points[j]);
    }

    // Final 2-isogeny if isogeny walk has odd length
    if(i < phi->length){
        fp2_t tmp;
        fp2_sqr(&A24.x, &G.x);
        fp2_sqr(&A24.z, &G.z);
        fp2_sub(&A24.x, &A24.z, &A24.x);
        fp2_add(&K.x, &G.x, &G.z);
        fp2_sub(&K.z, &G.x, &G.z);
        for(j = 0; j < length; j++){
            fp2_add(&G.x, &points[j].x, &points[j].z);
            fp2_sub(&G.z, &points[j].x, &points[j].z);
            fp2_mul(&tmp, &K.x, &G.z);
            fp2_mul(&G.z, &K.z, &G.x);
            fp2_add(&G.x, &tmp, &G.z);
            fp2_sub(&G.z, &tmp, &G.z);
            fp2_mul(&points[j].x, &points[j].x, &G.x);
            fp2_mul(&points[j].z, &points[j].z, &G.z);
        }
    }

    // Convert curve coefficient to (A:C)
    fp2_add(&image->A, &A24.x, &A24.x);
    fp2_sub(&image->A, &image->A, &A24.z);
    fp2_add(&image->A, &image->A, &image->A);
    fp2_copy(&image->C, &A24.z);
}
    
void ec_eval_odd(ec_curve_t* image, const ec_isog_odd_t* phi,
        ec_point_t* points, unsigned short length){
        
    ec_point_t ker_plus, ker_minus, P, K, A24, B24;
    int i,j,k;

    // Curve coefficient in the form A24 = (A+2C:4C)
    fp2_add(&A24.z, &phi->curve.C, &phi->curve.C);
    fp2_add(&A24.x, &phi->curve.A, &A24.z);
    fp2_add(&A24.z, &A24.z, &A24.z);

    // Isogenies with kernel in E[p+1]
    copy_point(&ker_plus, &phi->ker_plus);
    copy_point(&ker_minus, &phi->ker_minus);
    for(i = 0; i < P_LEN; i++){
        copy_point(&P, &ker_plus);
        for(j = i+1; j < P_LEN; j++){
            for(k = 0; k < phi->degree[j]; k++)
                xMULv2(&P, &P, &(TORSION_ODD_PRIMES[j]), p_plus_minus_bitlength[j], &A24);
        }
        for(k = 0; k < phi->degree[i]; k++){
            copy_point(&K, &P);
            for(j = 0; j < phi->degree[i]-k-1; j++)
                xMULv2(&K, &K, &(TORSION_ODD_PRIMES[i]), p_plus_minus_bitlength[i], &A24);
            kps(i, K, A24);
            xisog(&B24, i, A24);
            xeval(&P, i, P, A24);
            xeval(&ker_plus, i, ker_plus, A24);
            xeval(&ker_minus, i, ker_minus, A24);
            for(j = 0; j < length; j++)
                xeval(&points[j], i, points[j], A24);
            copy_point(&A24, &B24);
            kps_clear(i);
        }
    }

    // Isogenies with kernel in E[p-1]
    for(i = P_LEN; i < P_LEN+M_LEN; i++){
        copy_point(&P, &ker_minus);
        for(j = i+1; j < P_LEN+M_LEN; j++){
            for(k = 0; k < phi->degree[j]; k++)
                xMULv2(&P, &P, &(TORSION_ODD_PRIMES[j]), p_plus_minus_bitlength[j], &A24);
        }
        for(k = 0; k < phi->degree[i]; k++){
            copy_point(&K, &P);
            for(j = 0; j < phi->degree[i]-k-1; j++)
                xMULv2(&K, &K, &(TORSION_ODD_PRIMES[i]), p_plus_minus_bitlength[i], &A24);
            kps(i, K, A24);
            xisog(&B24, i, A24);
            xeval(&P, i, P, A24);
            xeval(&ker_minus, i, ker_minus, A24);
            for(j = 0; j < length; j++)
                xeval(&points[j], i, points[j], A24);
            copy_point(&A24, &B24);
            kps_clear(i);
        }
    }

    // Convert curve coefficient to (A:C)
    fp2_add(&image->A, &A24.x, &A24.x);
    fp2_sub(&image->A, &image->A, &A24.z);
    fp2_add(&image->A, &image->A, &image->A);
    fp2_copy(&image->C, &A24.z);
}

void ec_curve_normalize(ec_curve_t *new, ec_isom_t *isom, const ec_curve_t *old){
    fp2_t t0, t1, t2, t3, t4, t5;
    // Compute the other solutions:
    // A'^2 = [ sqrt(A^2-4C^2)*(9C^2-A^2) +- (A^3-3AC^2) ] / [ 2C^2*sqrt(A^2-4C^2) ]
    fp2_sqr(&t0, &old->C);      //C^2
    fp2_add(&t1, &t0, &t0);     //2C^2
    fp2_add(&t2, &t1, &t1);     //4C^2
    fp2_sqr(&t3, &old->A);      //A^2
    fp2_sub(&t2, &t3, &t2);     //A^2-4C^2
    fp2_sqrt(&t2);              //sqrt(A^2-4C^2)
    fp2_add(&t0, &t0, &t1);     //3C^2
    fp2_mul(&t1, &t2, &t1);     //2C^2*sqrt(A^2-4C^2)
    fp2_sub(&t5, &t3, &t0);     //A^2-3C^2
    fp2_mul(&t5, &t5, &old->A);     //A^3-3AC^2
    fp2_add(&t4, &t0, &t0);     //6C^2
    fp2_add(&t0, &t4, &t0);     //9C^2
    fp2_sub(&t0, &t0, &t3);     //9C^2-A^2
    fp2_add(&t3, &t3, &t3);     //2A^2
    fp2_mul(&t3, &t3, &t2);     //2A^2*sqrt(A^2-4C^2)
    fp2_mul(&t2, &t2, &t0);     //sqrt(A^2-4C^2)*(9C^2-A^2)
    fp2_add(&t0, &t2, &t5);     //sqrt(A^2-4C^2)*(9C^2-A^2) + (A^3-3AC^2)
    fp2_sub(&t2, &t2, &t5);     //sqrt(A^2-4C^2)*(9C^2-A^2) - (A^3-3AC^2)
    fp2_inv(&t1);               //1/2C^2*sqrt(A^2-4C^2)
    fp2_mul(&t0, &t0, &t1);     // First solution
    fp2_mul(&t2, &t2, &t1);     // Second solution
    fp2_mul(&t1, &t3, &t1);     // Original solution

    // Chose the lexicographically first solution
    int alive = 3;
    for(int i=0; i < NWORDS_FIELD; i++){
        if(alive == 3 && t2.re[i] > t0.re[i] && t2.re[i] > t1.re[i])
            alive--;
        if(alive == 3 && t1.re[i] > t0.re[i] && t1.re[i] > t2.re[i]){
            fp2_copy(&t1, &t2);
            alive--;
        }
        if(alive == 3 && t0.re[i] > t1.re[i] && t0.re[i] > t2.re[i]){
            fp2_copy(&t0, &t2);
            alive--;
        }
        if(alive == 2 && t0.re[i] > t1.re[i]){
            fp2_copy(&t0, &t1);
            alive--;
        }
        if(alive == 2 && t1.re[i] > t0.re[i])
            alive--;
        if(alive == 1)
            break;
    }
    for(int i=0; i < NWORDS_FIELD; i++){
        if(alive == 3 && t2.im[i] > t0.im[i] && t2.im[i] > t1.im[i])
            alive--;
        if(alive == 3 && t1.im[i] > t0.im[i] && t1.im[i] > t2.im[i]){
            fp2_copy(&t1, &t2);
            alive--;
        }
        if(alive == 3 && t0.im[i] > t1.im[i] && t0.im[i] > t2.im[i]){
            fp2_copy(&t0, &t2);
            alive--;
        }
        if(alive == 2 && t0.im[i] > t1.im[i]){
            fp2_copy(&t0, &t1);
            alive--;
        }
        if(alive == 2 && t1.im[i] > t0.im[i])
            alive--;
        if(alive == 1)
            break;
    }

    // Copy the solution
    fp2_sqrt(&t0);
    ec_curve_t E;
    fp2_copy(&E.A, &t0);
    fp_mont_setone(E.C.re);
    fp_set(E.C.im, 0);
    ec_isomorphism(isom, old, &E);
    fp2_copy(&new->A, &E.A);
    fp2_copy(&new->C, &E.C);
}

void ec_isomorphism(ec_isom_t* isom, const ec_curve_t* from, const ec_curve_t* to){
    fp2_t t0, t1, t2, t3, t4;
    fp2_mul(&t0, &from->A, &to->C);
    fp2_sqr(&t0, &t0);                  //fromA^2toC^2
    fp2_mul(&t1, &to->A, &from->C);
    fp2_sqr(&t1, &t1);                  //toA^2fromC^2
    fp2_mul(&t2, &to->C, &from->C);
    fp2_sqr(&t2, &t2);                  //toC^2fromC^2
    fp2_add(&t3, &t2, &t2);
    fp2_add(&t2, &t3, &t2);             //3toC^2fromC^2
    fp2_sub(&t3, &t2, &t0);             //3toC^2fromC^2-fromA^2toC^2
    fp2_sub(&t4, &t2, &t1);             //3toC^2fromC^2-toA^2fromC^2
    fp2_inv(&t3);
    fp2_mul(&t4, &t4, &t3);
    fp2_sqrt(&t4);                      //lambda^2 constant for SW isomorphism
    fp2_sqr(&t3, &t4);
    fp2_mul(&t3, &t3, &t4);             //lambda^6

    // Check sign of lambda^2, such that lambda^6 has the right sign
    fp2_sqr(&t0, &from->C);
    fp2_add(&t1, &t0, &t0);
    fp2_add(&t1, &t1, &t1);
    fp2_add(&t1, &t1, &t1);
    fp2_add(&t0, &t0, &t1); // 9fromC^2
    fp2_sqr(&t2, &from->A);
    fp2_add(&t2, &t2, &t2); // 2fromA^2
    fp2_sub(&t2, &t2, &t0);
    fp2_mul(&t2, &t2, &from->A); // -9fromC^2fromA+2fromA^3
    fp2_sqr(&t0, &to->C);
    fp2_mul(&t0, &t0, &to->C);
    fp2_mul(&t2, &t2, &t0);     //toC^3* [-9fromC^2fromA+2fromA^3]
    fp2_mul(&t3, &t3, &t2);             //lambda^6*(-9fromA+2fromA^3)*toC^3
    fp2_sqr(&t0, &to->C);
    fp2_add(&t1, &t0, &t0);
    fp2_add(&t1, &t1, &t1);
    fp2_add(&t1, &t1, &t1);
    fp2_add(&t0, &t0, &t1); // 9toC^2
    fp2_sqr(&t2, &to->A);
    fp2_add(&t2, &t2, &t2); // 2toA^2
    fp2_sub(&t2, &t2, &t0);
    fp2_mul(&t2, &t2, &to->A); // -9toC^2toA+2toA^3
    fp2_sqr(&t0, &from->C);
    fp2_mul(&t0, &t0, &from->C);
    fp2_mul(&t2, &t2, &t0);     //fromC^3* [-9toC^2toA+2toA^3]
    if(!fp2_is_equal(&t2, &t3))
        fp2_neg(&t4, &t4);

    // Mont -> SW -> SW -> Mont
    fp_mont_setone(t0.re);
    fp_set(t0.im, 0);
    fp2_add(&isom->D, &t0, &t0);
    fp2_add(&isom->D, &isom->D, &t0);
    fp2_mul(&isom->D, &isom->D, &from->C);
    fp2_mul(&isom->D, &isom->D, &to->C);
    fp2_mul(&isom->Nx, &isom->D, &t4);
    fp2_mul(&t4, &t4, &from->A);
    fp2_mul(&t4, &t4, &to->C);
    fp2_mul(&t0, &to->A, &from->C);
    fp2_sub(&isom->Nz, &t0, &t4);
}

void ec_iso_inv(ec_isom_t* isom){
    fp2_t tmp;
    fp2_copy(&tmp, &isom->D);
    fp2_copy(&isom->D, &isom->Nx);
    fp2_copy(&isom->Nx, &tmp);
    fp2_neg(&isom->Nz, &isom->Nz);
}

void ec_iso_eval(ec_point_t *P, ec_isom_t* isom){
    fp2_t tmp;
    fp2_mul(&P->x, &P->x, &isom->Nx);
    fp2_mul(&tmp, &P->z, &isom->Nz);
    fp2_sub(&P->x, &P->x, &tmp);
    fp2_mul(&P->z, &P->z, &isom->D);
}
